<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0031)http://psdraw.narod.ru/les6.htm -->
<HTML><HEAD><TITLE>Язык программирования PostScript: Урок 6</TITLE><LINK 
href="les6_files/main.css" type=text/css rel=STYLESHEET>
<META http-equiv=Content-Type content="text/html; CHARSET=Windows-1251">
<META 
content="PostScript программирование рисование печать язык программирования DPS lang .ps создание" 
name=Keywords>
<META content="MSHTML 6.00.2800.1528" name=GENERATOR></HEAD>
<BODY topMargin=10>
<TABLE borderColor=#c6c6c6 cellSpacing=3 width="100%" border=1>
  <TBODY>
  <TR bgColor=black>
    <TD vAlign=top align=left width="20%">
      <P class=level0><A href="http://psdraw.narod.ru/index.htm">Новости</A>
      <P class=level0><A href="http://psdraw.narod.ru/main.htm">О проекте</A>
      <P class=level0><A href="http://psdraw.narod.ru/why.htm">Зачем?</A>
      <P class=level0><A href="http://psdraw.narod.ru/soft.htm">Используемое 
      ПО</A>
      <P class=level0><A href="http://psdraw.narod.ru/metoda.htm">Методика 
      разработки сцен на PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/stnd.htm">Операторы языка 
      PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/lib.htm">Библиотека</A>
      <P class=level0><A href="http://psdraw.narod.ru/les.htm">Изучение 
языка</A>
      <P class=level1><A href="http://psdraw.narod.ru/les1.htm">Урок 1</A>
      <P class=level1><A href="http://psdraw.narod.ru/les2.htm">Урок 2</A>
      <P class=level1><A href="http://psdraw.narod.ru/les3.htm">Урок 3</A>
      <P class=level1><A href="http://psdraw.narod.ru/les4.htm">Урок 4</A>
      <P class=level1><A href="http://psdraw.narod.ru/les5.htm">Урок 5</A>
      <P class=level1>Урок 6
      <P class=level1><A href="http://psdraw.narod.ru/les7.htm">Урок 7</A>
      <P class=level0><A href="http://psdraw.narod.ru/s_sss.htm">Статьи</A>
      <P class=level0><A 
      href="http://psdraw.narod.ru/links.htm">Ссылки...</A></P></TD>
    <TD vAlign=top>
      <H1>Занятие шестое</H1>
      <H2>Встраивание PostScript-программ в документы</H2>
      <P>Так как в России наиболее широко для издательской подготовки текстов и 
      даже для вёрстки используется <B>Word</B> для Windows, то следующей 
      вопрос, который требует пояснения, - как встроить программу на PostScript 
      в документ Word. Дело в том, что Word имеет собственный формат файлов, а 
      программа на PostScript - это обычный ASCII-текст. Разработчики решили эту 
      задачу просто: они оставили для таких случаев лазейку, которая называется 
      поле <B>print</B>. Напомню, что полями в Word называются специальные 
      команды редактора, заключённые в фигурные скобки. Поле <B>print</B> 
      предназначено для того, чтобы выводить символы непосредственно на принтер 
      (например, команды прямого управления принтером, команды на языке 
      <B>PCL</B> и, конечно, <B>PostSript</B>-программы). Формат поля: <PRE class=example>   {print \p Size "текст"} </PRE>
      <P>Ключ <B>\p</B> указывает, что в поле текст будет записана 
      PostSript-программа. Операторы PostScript, заданные в этом поле, могут 
      работать только в окне рисования, определённом атрибутом <B>Size</B>, 
      значения которого приведены в таблице. 
      <TABLE width="90%" align=center>
        <TBODY>
        <TR class=shapka>
          <TD>Аргумент</TD>
          <TD>Значение</TD></TR>
        <TR>
          <TD>page</TD>
          <TD>Рисунок на всей текущей странице (по умолчанию)</TD></TR>
        <TR>
          <TD>para</TD>
          <TD>В пределах абзаца (высотой не менее дюйма), содержащего поле 
            <B>print</B></TD></TR>
        <TR>
          <TD>pic</TD>
          <TD>Рисунок располагается после поля <B>print</B> и до конца абзаца, 
            содержащего это поле</TD></TR>
        <TR>
          <TD>row</TD>
          <TD>Рисунок в текущей строке таблицы</TD></TR>
        <TR>
          <TD>cell</TD>
          <TD>Рисунок в текущем элементе таблицы</TD></TR>
        <TR>
          <TD>Dict</TD>
          <TD>Используется для создания определений и процедур на PostScript, 
            которые будут выполнены позже на той же самой странице. Поэтому 
            <B>dict</B> не следует использовать для 
      рисования.</TD></TR></TBODY></TABLE>
      <P>Так как текст и графика документа Word печатаются на той же 
      PostScript-странице, что и результат PostScript-программы, не следует 
      использовать операторы, которые изменяют или сбрасывают среду PostScript, 
      а именно, избегайте операторов: <B>banddevice</B>, <B>copypage</B>, 
      <B>framedevice</B>, <B>grestoreall</B>, <B>initgraphics</B>, 
      <B>initmatrix</B>, <B>nulldevice</B>, <B>renderbands</B> и 
      <B>showpage</B>. 
      <P>При работе с PostScript в Word вам доступны переменные, которые я свёл 
      в следующую таблицу. Значения, представленные этими переменными, даны в 
      пунктах. 
      <TABLE width="90%" align=center>
        <TBODY>
        <TR class=shapka>
          <TD>Size</TD>
          <TD>Переменная</TD>
          <TD>Описание</TD></TR>
        <TR>
          <TD>Для всех аргументов</TD>
          <TD>wp$x</TD>
          <TD>Ширина прямоугольника рисования для заданного аргумента 
            <B>Size</B></TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$y</TD>
          <TD>Высота прямоугольника рисования для заданного аргумента 
            <B>Size</B></TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$page</TD>
          <TD>Текущий номер страницы</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$fpage</TD>
          <TD>Отформатированный номер страницы (строка)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$date</TD>
          <TD>Текущая дата (строка)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$time</TD>
          <TD>Текущая дата (строка)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$box</TD>
          <TD>Путь, содержащий прямоугольник рисования</TD></TR>
        <TR>
          <TD>&nbsp;</TD>
          <TD></TD>
          <TD></TD></TR>
        <TR>
          <TD>page, para</TD>
          <TD>wp$top</TD>
          <TD>Верхняя граница (page); расстояние до (para)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$bottom</TD>
          <TD>Нижняя граница (page); расстояние после (para)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$left</TD>
          <TD>Левая граница (page); левый отступ (para)</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$right</TD>
          <TD>Правая граница (page); правый отступ (para)</TD></TR>
        <TR>
          <TD>&nbsp;</TD>
          <TD></TD>
          <TD></TD></TR>
        <TR>
          <TD>page</TD>
          <TD>wp$col</TD>
          <TD>Число столбцов на странице. Это число может различаться в 
            зависимости от секции документа, в которой появилось поле с 
            PostScript-операторами</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$colx</TD>
          <TD>Ширина каждого столбца</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$colxb</TD>
          <TD>Расстояние между столбцами</TD></TR>
        <TR>
          <TD>&nbsp;</TD>
          <TD></TD>
          <TD></TD></TR>
        <TR>
          <TD>para</TD>
          <TD>wp$first</TD>
          <TD>Отступ до первой строки</TD></TR>
        <TR>
          <TD></TD>
          <TD>wp$style</TD>
          <TD>Стиль</TD></TR></TBODY></TABLE>
      <P>Пример. <PRE class=example>   {print \p page "/Times-Roman findfont strsize scalefont 0.8 setgray"} </PRE>
      <H2>Ещё о типах данных</H2>
      <P>Все данные, доступные PostScript-программам, существуют в виде 
      объектов. Объекты делятся на простые, не имеющие внутренней структуры, и 
      сложные (или составные). К последним относятся строки, массивы и словари. 
      <P>Говоря о строках в PostScript, следует отметить, что в нём, как и в 
      языке Си, есть возможность с помощью обратной косой черты и следующего за 
      ним символа задавать специальные и управляющие символы. Вот ещё одна 
      полезная таблица с такими комбинациями знаков. 
      <TABLE width="50%" align=center>
        <TBODY>
        <TR class=shapka>
          <TD>Комбинация
          <TD>Символ</TD>
        <TR>
          <TD>\n</TD>
          <TD>новая строка</TD>
        <TR>
          <TD>\r
          <TD>возврат каретки</TD>
        <TR>
          <TD>\t
          <TD>табуляция</TD>
        <TR>
          <TD>\b
          <TD>возврат на позицию</TD>
        <TR>
          <TD>\f
          <TD>перевод формата</TD>
        <TR>
          <TD>\\
          <TD>обратная косая черта</TD>
        <TR>
          <TD>\(
          <TD>левая скобка</TD>
        <TR>
          <TD>\)
          <TD>правая скобка</TD>
        <TR>
          <TD>\ddd
          <TD>символ с восьмеричным кодом ddd</TD></TR></TBODY></TABLE>
      <P>Если за <B>\</B> следует символ, не перечисленный выше, то и он, и 
      обратная косая черта игнорируются. Следующие две строки одинаковы: <PRE class=example>(Строка с символом перевода строки.
)
            и
(Строка с символом перевода строки.\n) </PRE>
      <H2>Операторы для работы со словарями</H2>
      <P>Ещё один тип данных, о котором мы почти не говорили, - словари. <B 
      class=operator>Словарь</B> - это ассоциативная таблица, элементы которой - 
      пары PostScript-объектов. Первый элемент пары называется ключом, а второй 
      - значением. 
      <P>Обычно в качестве ключей используются имена объектов, а в качестве 
      значений - переменные и процедуры. В частности, шрифты в PostScript также 
      задаются словарями: именам символов соответствуют процедуры рисования 
      образов этих символов. Есть и другие примеры использования словарей. В 
      языке есть операторы, которые ищут ключ и выбирают соответствующее ему 
      значение, вставляют пару ключ--значение в словарь и выполняют некоторые 
      другие действия. 
      <P>Для работы со словарями в языке имеется специальный стек. Словарь, 
      находящийся в вершине этого стека, называется текущим словарём. Обычно, 
      встречая имя объекта в выполняемой программе, интерпретатор обращается с 
      ним к текущему словарю. Если он не находит там это имя, он обращается к 
      словарю, расположенному в стеке словарей вслед за текущим, и так далее, 
      пока не будут просмотрены все словари в стеке. 
      <P>В интерпретаторе имеется два встроенных словаря, называющихся 
      <B>systemdict</B> и <B>userdict</B> (в PostScript Level 2 к ним добавился 
      ещё один словарь - <B>globaldict</B>). Первый из них связывает 
      (ассоциирует) имена всех операторов языка с их значениями (т. е. 
      действиями, которые выполняются самим интерпретатором). Второй словарь 
      предназначен для связи имён переменных среды с их значениями. Оба 
      встроенных словаря находятся внизу стека (userdict над systemdict) и не 
      могут быть из него удалены. 
      <P><B class=operator>dict</B> создает пустой словарь ёмкостью <B>N</B> 
      элементов. <PRE class=example>  число_элементов dict    -&gt;  словарь</PRE>
      <P>Этот пустой словарь помещается в стек операндов. Аргумент 
      число_элементов не может быть отрицательным. 
      <P><B class=operator>currentdict</B> выполняет обратное действие - 
      помещает копию текущего словаря в стек операндов. <PRE class=example>  currentdict              -&gt; словарь</PRE>
      <P><B class=operator>countdictstack</B> пересчитывает число словарей, 
      находящихся в стеке словарей, и помещает это число в стек операндов. <PRE class=example>  countdictstack           -&gt; int</PRE>
      <P><B class=operator>cleardictstack</B> извлекает из стека все словари, 
      кроме постоянных. <PRE class=example>  cleardictstack           -&gt; -</PRE>
      <P><B class=operator>put</B> используется для замены или внесения нового 
      элемента в словарь. На самом деле этот оператор полиморфен и позволяет 
      также заменять элементы массивов и строк. <PRE class=example>  массив  индекс значение put  -&gt; -
  словарь ключ   значение put  -&gt; -
  строка  индекс целое    put  -&gt; - </PRE>
      <P>Если первый операнд массив или строка, то второй рассматривается как 
      индекс, значение которого лежит в диапазоне от <B>0</B> до <B>n-1</B> (где 
      <B>n</B> - длина строки или массива). Элемент с этим индексом замещается 
      третьим операндом. 
      <P>Если первый операнд - массив, то второй - рассматривается как ключ и в 
      словаре сохраняется пара ключ--значение, если данный ключ не будет найден, 
      либо замещается только значение, если пара с таким ключом уже существует. 
      Конечно, при создании нового входа в словарь интерпретатор проверяет 
      наличие там свободного места и выдаёт сообщение об ошибке <B>dictfull</B>, 
      если число входов уже исчерпано. Например: <PRE class=example> /mydict 10 dict def
  mydict /A 65 put  </PRE>
      <P><B class=operator>get</B> выполняет обратное действие. С его помощью 
      можно получить значение элемента массива, строки или по ключу найти 
      соответствующее значение в словаре. <PRE class=example> массив  индекс put  -&gt; значение
 словарь ключ   put  -&gt; значение
 строка  индекс put  -&gt; целое </PRE><PRE class=example>  /abc [1 2 3] def
    currentdict /abc get а [1 2 3]</PRE>
      <P>Со словарём очень интересно работает также оператор <B 
      class=operator>forall</B>. Ранее его действие рассматривалось только по 
      отношению к массиву, но он, как и два предыдущих оператора, работает и со 
      словарями, и со строками. <PRE class=example> массив  proc forall  -&gt;  -
 словарь proc forall  -&gt;  -
 строка  proc forall  -&gt;  - </PRE>
      <P>Если первый операнд - словарь, то <B>forall</B> помещает ключ и 
      значение в стек операндов и выполняет заданную процедуру (<B>proc</B>) над 
      каждой парой ключ--значение в словаре. Если процедура пустая "<B>{}</B>", 
      то таким образом все пары из словаря просто переписываются в стек 
      операндов. 
      <H2>Объекты типа operator</H2>
      <P>Этот несколько необычный для языков программирования тип объектов в 
      PostScript означает одно из встроенных в язык действий, вызываемое при 
      исполнении объекта. Операторы имеют имена, большинство из которых хранится 
      в <B>systemdict</B> в качестве ключей, а значением является программа, 
      реализующая семантику данного оператора. 
      <P>Другие типы объектов (<B>name</B>, <B>file</B>, <B>mark</B>, 
      <B>null</B>, <B>save</B>, <B>fontID</B>), которые не были рассмотрены до 
      сих пор, мы изучим в разделах, с ними непосредственно связанных. Но вот 
      что важно для объектов всех типов: каждый объект кроме типа и значения 
      имеет один или несколько атрибутов, которые влияют на поведении объекта 
      при его исполнении или когда над ним выполняются определённые операции 
      (кроме случая, когда объект рассматривается только как данные). 
      <H2>Атрибуты объекта</H2>
      <P>Каждый объект либо литерал (<B>literal</B>), либо 
      исполняемый(<B>executable</B>). Это важно для интерпретатора при 
      исполнении PostScript-программы. Отметим, что при такие операторы, как 
      "<B>[</B>" и "<B>]</B>" создают литеральные объекты, а операторы 
      "<B>{</B>" и "<B>}</B>" - исполняемые. Другим атрибутом объекта является 
      тип доступа (<B>access</B>) к нему. Имеется четыре типа доступа 
      (расположены в списке по возрастанию ограничений): неограниченный 
      (<B>unlimited</B>), только чтение (<B>read only</B>), только исполнение 
      (<B>execute-only</B>) и без доступа (<B>none</B>). 
      <P>Как правило, объект имеет неограниченный доступ. Это означает, что 
      допускается применение к нему всех операторов, какие определены для работы 
      с ним. Объекты с атрибутом "только чтение" не допускают модификацию своего 
      значения и могут быть только считаны или выполнены. Аналогично, атрибут 
      "только исполнение" определяет, что объект не может быть прочитан, а 
      только исполнен интерпретатором. И наконец, объекты с атрибутом "без 
      доступа" служат для каких-то внутренних целей, о которых я в данный момент 
      ничего не знаю. Понятно, что они не используются программами напрямую. Для 
      получения типа объекта служит оператор <B class=operator>type</B>. <PRE class=example> объект type    -&gt;  имя_типа</PRE>
      <P>Результатом операции может быть одно из перечисленных имен: 
      <TABLE width="50%" align=center>
        <TBODY>
        <TR>
          <TD><B>arraytype </B>
          <TD><B>booleantype </B>
          <TD><B>dicttype </B></TD>
        <TR>
          <TD><B>filetype </B>
          <TD><B>fonttype </B>
          <TD><B>integertype </B></TD>
        <TR>
          <TD><B>marktype </B>
          <TD><B>nametype </B>
          <TD><B>nulltype </B></TD>
        <TR>
          <TD><B>operatortype </B>
          <TD><B>realtype </B>
          <TD><B>savetype </B></TD>
        <TR>
          <TD><B>stringtype </B>
          <TD>
          <TD></TD></TR></TBODY></TABLE>
      <P>Следующие три оператора проверяют соответственно тип доступа объекта: 
      <OL>
        <LI><B class=operator>wcheck</B> - возвращает <B>true</B>, если объект 
        имеет атрибут <B>ulimited</B>; 
        <LI><B class=operator>xcheck</B> - возвращает <B>true</B>, если объект 
        исполняемый, и <B>false</B>, если литерал; 
        <LI><B class=operator>rcheck</B> - возвращает <B>true</B>, если объект 
        "только для чтения". </LI></OL>
      <P>Синтаксис у них одинаковый. Например, для <B>wcheck</B> он выглядит 
      так: <PRE class=example> объект wcheck    -&gt;  лог_значение </PRE>
      <P>Операторы <B class=operator>cvlit</B> и <B class=operator>cvx</B> 
      позволяют изменить атрибут объекта, находящегося в вершине стека 
      операндов, с исполняемого на литеральный и наоборот. <PRE class=example>  объект cvlit    -&gt;  объект
  объект cvx      -&gt;  объект </PRE>
      <H2>Виртуальная память</H2>
      <P><B>Виртуальной памятью</B> (обозначается <B>VM</B>) называется область 
      памяти, в которой хранятся значения составных объектов. В некоторых 
      реализациях PostScript может сохранять <B>VM</B> в файле в конце сеанса и 
      восстанавливать её в начале следующего. Сохранить и восстановить текущее 
      состояние <B>VM</B> во время выполнения программы можно также с помощью 
      операторов <B>save</B> и <B>restore</B>, а проверить состояние <B>VM</B> - 
      с помощью оператора <B>vmstatus</B>. 
      <H2>Цветовые модели в PostScript</H2>
      <P>В языке поддерживаются две цветовые модели: <B>HSB</B> 
      (тон-насыщенность-яркость) и <B>RGB</B> (красный-зеленый-голубой). В 
      каждой из этих моделей можно задать любой цвет с помощью трёх числовых 
      параметров. В более простой модели <B>RGB</B> цвет задаётся сочетанием 
      интенсивности трёх основных цветов: <U>красного</U>, <U>зеленого</U> и 
      <U>голубого</U>. Интенсивность цвета задаётся числом в диапазоне от 
      <B>0</B> до <B>1</B>, причём <B>0</B> означает полное отсутствие данного 
      цвета, а <B>1</B> - его максимальную интенсивность. Если для всех трёх 
      цветов заданы равные интенсивности, то в результате получится чистый серый 
      цвет с градацией по всей шкале от белого (0, 0, 0) до черного (1, 1, 1). 
      Напомню, что уровень серого цвета обычно устанавливается оператором 
      <B>setgray</B>. 
      <P>В <B>HSB</B> тон задаёт собственно цвет. Он определяется его 
      расположением на цветовом круге: <B>0°</B> -- чистый красный, <B>120°</B> 
      -- зелёный, <B>240°</B> -- синий. Остальные цвета получаются из смешения 
      двух соседних. (Так, 60° -- жёлтый, , 180° -- голубой, 300° -- 
      фиолетовый.) <B>Насыщенность</B> - густота цвета заданного тона: <B>0</B> 
      соответствует отсутствию цвета, а <B>1</B> - максимальной его 
      насыщенности. <B>Яркость</B> - общая интенсивность цвета (содержание 
      белого цвета в данном цвете): <B>0</B> соответствует чёрному цвету, а 
      <B>1</B> - белому (максимальной интенсивности). 
      <P>Цвет может быть задан с помощью соответствующих модели операторов <B 
      class=operator>setrgbcolor</B> и <B class=operator>sethsbcolor</B>. 
      <H2>Выборка произвольного элемента из стека</H2>
      <P>Оператор <B class=operator>index</B> удаляет неотрицательное целое 
      число <B>n</B> из стека операндов, отсчитывает n-й элемент от вершины 
      стека и помещает копию этого элемента в стек. Это очень напоминает выборку 
      элемента массива. При этом первый элемент в стеке имеет индекс <B>0</B>. 
      Вместе с операторами <B>copy</B>, <B>dup</B> и <B>roll</B> он позволяет 
      свободно манипулировать содержимым стека операндов. <PRE class=example>  an ... a0 n index     -&gt;  an ... a0 an </PRE>
      <P>Пример. Обозначим буквами содержимое стека, тогда: <PRE class=example> A D G     0 index    -&gt; A D G G
 A D G J F 4 index    -&gt; A D G J F A</PRE>
      <P><B class=operator>clear</B> извлекает все объекты из стека операндов и 
      уничтожает их. <PRE class=example> a1 ... an   clear    -&gt; - </PRE>
      <P><B class=operator>count</B> пересчитывает число элементов в стеке 
      операндов и возвращает его в вершине стека. <PRE class=example> a1 ... an   count    -&gt; a1 ... an n </PRE><PRE class=example>  clear       count   -&gt; 0
  clear 1 2 3 count   -&gt; 1 2 3 3 </PRE>
      <P><B class=operator>countexecstack</B> считает число объектов в стеке 
      исполнения и помещает это число в стек операндов. <PRE class=example>  countexecstack      -&gt; int </PRE>
      <P><B class=operator>counttomark</B> считает число любых объектов в стеке 
      операндов начиная с вершины стека и до первого маркера (не включая его 
      самого). <PRE class=example>  mark ob1 ... obn counttomark  -&gt;  mark ob1 ... obn n </PRE><PRE class=example> 1 mark 2 3 counttomark         -&gt;  1 mark 2 3 2 </PRE>
      <P><B class=operator>cleartomark</B> извлекает любые объекты из стека 
      операндов, пока не будет достигнут маркер, который также удаляется из 
      стека. <PRE class=example>  mark ob1 ... obn cleartomark  -&gt;  - </PRE>
      <H2>Ещё о работе с отсечениями</H2>
      <P>Операторы <B>clip</B> и <B>clippath</B> мы рассмотрели на прошлом 
      занятии. Теперь несколько углубим эту важную тему. 
      <P><B class=operator>eoclip</B> находит пересечение внутри текущей 
      траектории отсечения с внутренней областью текущей траектории, чтобы 
      создать новый, меньший текущий путь отсечения. Область внутри текущего 
      пути определяется по правилу чётное-нечётное, тогда как область внутри 
      текущего пути отсечения определяется правилом, использованным при создании 
      данного пути отсечения. 
      <P>За исключением указанных правил, действие оператора <B>eoclip</B> 
      аналогично действию оператора <B>clip</B>. <PRE class=example>  eoclip    -&gt;   - </PRE>
      <P><B class=operator>initclip</B> замещает параметр текущей траектории 
      отсечения в состоянии графической среды на траекторию отсечения, 
      устанавливаемую для текущего графического устройства по умолчанию. Этот 
      путь обычно соответствует границам максимально большой области для вывода 
      изображения. Для устройств, ориентированных на постраничный вывод, его 
      размерности устанавливаются оператором <B>setpagedevice</B>. Для экрана 
      область отсечения, устанавливаемая оператором <B>initclip</B>, не очень 
      хорошо определена. 
      <P>Ситуаций, когда в PostScript-программе следует применять оператор 
      <B>initclip</B>, не так много. Описание страницы, в которой применён этот 
      оператор, обычно даёт некорректный результат, если оно встроено в другую, 
      составную страницу. <PRE class=example>  initclip  -&gt;   - </PRE>
      <P><B class=operator>eoviewclip</B> (L2) аналогичен оператору 
      <B>viewclip</B> за исключением того, что использует правило 
      чётный-нечётный для определения области внутри пути отсечения. <PRE class=example> eoviewclip -&gt;   - </PRE>
      <P>К сожалению, за одно занятие удаётся рассказать не так много, как 
      хотелось бы, поэтому рекомендую посмотреть очень полезные примеры программ 
      на PostScript из Голубой книги по адресу: <A 
      href="http://www.fwi.uva.nl/~heederik/ps/bluebook/">http://www.fwi.uva.nl/~heederik/ps/bluebook/</A> 

      <P class=date>21.11.2001 </P></TD></TR></TBODY></TABLE>
<CENTER>
<HR>

<HR width="50%">
©Фурашев А. 2002<BR><A href="mailto:psdraw@narod.ru">e-mail</A>
<HR width="25%">

<HR width="12%">
<!-- ><!-- "><!-- '><!-- --></TEXTAREA></FORM> </TITLE></COMMENT></A>
<DIV></DIV></SPAN></ILAYER></LAYER></IFRAME></NOFRAMES></STYLE></NOSCRIPT></TABLE></SCRIPT></APPLET></FONT>
<STYLE>#bn {
	DISPLAY: block
}
#bt {
	DISPLAY: block
}
</STYLE>

<SCRIPT language=JavaScript src="les6_files/163"></SCRIPT>
<!-- mailto:spm111@yandex.ru --></CENTER></BODY></HTML>
