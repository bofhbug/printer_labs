<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0031)http://psdraw.narod.ru/les4.htm -->
<HTML><HEAD><TITLE>Язык программирования PostScript: Урок 4</TITLE><LINK 
href="les4_files/main.css" type=text/css rel=STYLESHEET>
<META http-equiv=Content-Type content="text/html; CHARSET=Windows-1251">
<META 
content="PostScript программирование рисование печать язык программирования DPS lang .ps создание" 
name=Keywords>
<META content="MSHTML 6.00.2800.1528" name=GENERATOR></HEAD>
<BODY topMargin=10>
<TABLE borderColor=#c6c6c6 cellSpacing=3 width="100%" border=1>
  <TBODY>
  <TR bgColor=black>
    <TD vAlign=top align=left width="20%">
      <P class=level0><A href="http://psdraw.narod.ru/index.htm">Новости</A>
      <P class=level0><A href="http://psdraw.narod.ru/main.htm">О проекте</A>
      <P class=level0><A href="http://psdraw.narod.ru/why.htm">Зачем?</A>
      <P class=level0><A href="http://psdraw.narod.ru/soft.htm">Используемое 
      ПО</A>
      <P class=level0><A href="http://psdraw.narod.ru/metoda.htm">Методика 
      разработки сцен на PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/stnd.htm">Операторы языка 
      PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/lib.htm">Библиотека</A>
      <P class=level0><A href="http://psdraw.narod.ru/les.htm">Изучение 
языка</A>
      <P class=level1><A href="http://psdraw.narod.ru/les1.htm">Урок 1</A>
      <P class=level1><A href="http://psdraw.narod.ru/les2.htm">Урок 2</A>
      <P class=level1><A href="http://psdraw.narod.ru/les3.htm">Урок 3</A>
      <P class=level1>Урок 4
      <P class=level1><A href="http://psdraw.narod.ru/les5.htm">Урок 5</A>
      <P class=level1><A href="http://psdraw.narod.ru/les6.htm">Урок 6</A>
      <P class=level1><A href="http://psdraw.narod.ru/les7.htm">Урок 7</A>
      <P class=level0><A href="http://psdraw.narod.ru/s_sss.htm">Статьи</A>
      <P class=level0><A 
      href="http://psdraw.narod.ru/links.htm">Ссылки...</A></P></TD>
    <TD vAlign=top>
      <H1>Занятие четвёртое</H1>
      <P>Начиная весной эту серию уроков у меня было сомнение -- хватит ли 
      материала на семь занятий. Задав в Интернет поиск по ключевому слову 
      PostScript и получив сообщение, что найдено более 99 тыс. документов, где 
      оно встречается, я успокоился - об этом языке писать можно до 2000 года. 
      Кроме того, обнаружилась книга по PostScript и на русском языке. Это 
      изданный Физматлитом в 1993 г. учебник: Ф.Доймлинг, Д.Стиллеску "Язык 
      программирования PostScript. 20 уроков быстрого освоения". В ней очень 
      детально описывается то, что нами будет пройдено на четырех первых уроках. 
      Следует отметить, что наши занятия методически следуют книге "PostScript 
      Language Tutorial and Cookbook" (Adobe Systems &amp; Addison Wesley, 
      1987), являющейся де-факто описанием стандарта языка и потому именуемой 
      "Голубой книгой". Тем у кого это издание есть, я рекомендую подождать 
      седьмого урока, который будет отчасти посвящён текущему состоянию языка, 
      литературе и другим не описанным в "Голубой книге" вопросам. 
      <H2>Циклы</H2>
      <P>В языке PostScript имеется три основных конструкции циклов: простой 
      цикл, индексируемый цикл и условный цикл. 
      <P>Простой цикл неявным образом уже использовался в примерах предыдущего 
      занятия. Он реализуется с помощью оператора <B>repeat</B>, который берет 
      из стека два операнда: счетчик цикла и повторяемую процедуру. Например, 
      для очистки стека мы использовали следующий цикл: <PRE class=example>   4 {pop} repeat </PRE>
      <P>Здесь всё достаточно прозрачно, непривычно, может быть, только то, что 
      в качестве одного из аргументов выступает повторяемая процедура. 
      <P>Индексируемый цикл напоминает широко известную по Бейсику конструкцию 
      <B>for... to... next</B>. Оператор <B>for</B> берет из стека четыре 
      операнда: начальное значение счетчика цикла, его приращение, конечное 
      значение счетчика цикла и повторяемую процедуру. За исключением последнего 
      операнда всё выглядит как и в обычной конструкция <B>for</B>. Следует 
      учитывать, что непосредственно перед выполнением этой процедуры <B>for</B> 
      помещает в стек текущее значение счетчика и, если он не используется, то 
      его следует оттуда явным образом <U>удалять</U>(!). 
      <P>Следующая строка напечатает звездочку через каждые 15 единиц на 
      странице: <PRE class=example>0 15 450 {0 moveto (*) show } for </PRE>
      <P>Вторая важная особенность <B>for</B> в том, что его операнды не 
      обязательно должны быть целыми числами. Вот пример использования этого для 
      возможной модификации шрифта: <PRE class=example>/Helvetica findfont
              30 scalefont
                 setfont
/printword {
               0 0 moveto
   (PC Magazine) show
} def

  200 300 translate
  .95 -.05  0      % начало приращения, конец
    {setgray printword -1.5  translate} for

   1 setgray printword
 showpage </PRE>
      <P>Условный цикл соответствует конструкции <B>repeat...until</B> в 
      Паскале. Строится он из двух операторов: <B>loop</B> и <B>exit</B>. 
      Опертор <B>loop</B> повторяет выполнение процедуры до тех пор пока в ней 
      не встретится оператор <B>exit</B>, который заканчивает циклическое 
      выполнение, причем не только в конструкции <B>loop</B>, но и в <B>for</B>, 
      <B>repeat</B> и <B>forall</B> (об этой специальной форме цикла будет 
      расказано ниже). Если в повторяемой процедуре нет оператора <B>exit</B>, 
      то цикл будет бесконечным, например: <PRE class=example> { (PostScript) show } loop </PRE>
      <P>будет бесконечно печатать слово <B>PostScript</B>. 
      <P>Нарисуем незамысловатую последовательность кругов просто, чтобы 
      продемонстрировать работу <B>loop - exit</B>. <PRE class=example> %%% Определение процедур
  /pagewidth 8 72 mul def % Ширина страницы
  /circle  {              % Рисование круга
    x   y radius
    0 360 arc
          stroke
  } def

  /new-x {                % Новая позиция для следующ. круга
     x radius add    % Это эквивалентно:
     /x exch def     % х=х+radius
  } def

  /DoLineOfCrle {         % Рисуем линию из окружностей
     /y      exch def  % заносим значения из стека в переменные
     /radius exch def
     /x      0    def
    {                  % условный цикл
      x pagewidth le   % центр нового круга в пределах границы?
       {circle new-x}  % да: рисуем и вычисл новую позицию
       {exit}          % иначе - выход из цикла
      ifelse
    } loop
  } def

 %%%% Рисуем две линии кругов
 15 200 DoLineOfCrle
 25 200 DoLineOfCrle
showpage
</PRE>
      <H2>Массивы</H2>
      <P>PostScript работает с одномерными массивами - (векторами), которые 
      определяются как набор объектов (возможно разного типа), заключенный в 
      квадратные скобки. Так <PRE class=example>[ (PC Magazine) 1991 54]
         и
[ (Julia) 4 12 78] </PRE>
      <P>массивы, причем первый элемент этих массивов - строка. (Такие структуры 
      в других языках, кроме АПЛ, обычно называют записями). Операции внутри 
      квадратных скобок выполняются по обычным правилам PostScript, так после 
      вычисления <PRE class=example>[(add) 10 5 6 mul sub] </PRE>
      <P>получим массив из двух элементов. 
      <P>Массив может быть также определен с помощью оператора <B>array</B>, 
      который берет из стека число и создает массив такой длины. <PRE class=example>  8 array </PRE>
      <P>Эта строка оставит в стеке массив из 8 элементов. Его элементы -- 
      <B>NULL</B>-объекты. 
      <P>Когда массив создается строкой типа <PRE class=example>   [1 2 3 8 ]</PRE>
      <P>то квадратные скобки, используемые для его записи играют в PostScript 
      большую роль, чем это кажется на первый взгляд. Открывающая (левая) 
      квадратная скобка оставляет в стеке объект, называемый маркером 
      (<B>mark</B>). После маркера интерпретатор просматривает строку программы 
      дальше и помещает в стек все встречающиеся ему объекты до правой 
      квадратной скобки. Эта скобка является оператором, создающим массив из 
      хранящихся в стеке объектов: от вершины до маркера. При этом маркер 
      удаляется из стека, а массив остаётся. 
      <P>Массивы, строки и словари -- всё это примеры объектов сложных типов. Их 
      значения хранятся PostScript отдельно от самого объекта (то есть 
      PostScript работает в этом случае не со значением, а с указателем на 
      него). Так операция <B>dup</B> над строкой дублирует объект, но не его 
      значение, которое в этом случае разделяется двумя объектами. Массив в 
      PostScript индексируются с нуля. Для работы с элементами массивов служат 
      операторы <B>put</B> и <B>get</B>. 
      <P>Оператор <B>put</B> берет из стека три аргумента: массив, индекс 
      элемента в массиве и объект. Он помещает объект в массив в позицию, 
      заданную индексом: <PRE class=example> /MyArray 12 array def
    MyArray 5 (Jerry) put  </PRE>
      <P>У оператора <B>get</B> два аргумента: массив и индекс. Он возвращает в 
      стеке элемент массива с заданным индексом. После выполнения строки <PRE class=example>   [0 1 2 3 4 5] 5 get </PRE>
      <P>в вершине стека будет число 4. 
      <P>Для работы с массивами также необходим оператор <B>length</B>, 
      возвращающий длину массива (то есть число его элементов). Следующая 
      программа распечатывает массив, находящийся в стеке. <PRE class=example>  /LeftM 60 def
  /TmpString 40 string def
  /Helvetica findfont
          11 scalefont
             setfont     % задали шрифт

  /newln {
     currentpoint 15 sub exch pop    % y-15
     LeftM exch moveto
  } def

 /printarr {     % в стеке массив
   /arr exch def % поместить массив в переменную
   0 1           % параметры цикла: от шаг
      arr length 1 sub % до (ДлинаМассива - 1)
   {
      arr exch get   % следующий элемент
      TmpString cvs  % преобразуем вго в строков тип
      show newln     % печатаем и нач. новую строку
   } for
} def

%%%%%% Основная программа %%%%%
  LeftM 400 moveto % печатаем отсюда
     % задаем массив
 [(Julia)     % строка
   15         % число
   /SimplName % литерал
   [8 3 4]    % массив
   {NewLN}    % исполняемый массив
   LeftM      % переменная
 ]
    printarr % печатаем его
 showpage </PRE>
      <P>Перед каждым выполнением цикла оператор <B>for</B> помещает в стек 
      счетчик, который используется в качестве индекса в строке <B>arr exch 
      get</B>. (В этой строке берется не сам массив из стека, а ссылка на него 
      по имени переменной, поэтому и делается exch.) 
      <P>Результат работы программы <PRE class=example>    Julia
    15
    SimplName
    --nostringval--
    --nostringval--
    60 </PRE>
      <P>Как видно из примера обычные действия над массивом в PostScript 
      достаточно утомительны. Так как наиболее частой операцией над массивом в 
      этом языке является применение некоторой процедуры к каждому его элементу, 
      то для этого есть очень красивый оператор <B>forall</B>, который применяет 
      к массиву-аргументу заданную процедуру. Предыдущий пример можно записать с 
      его помощью более компактно: <PRE class=example>   arr {30 string cvs show} forall </PRE>
      <H2>Полиморфные операторы</H2>
      <P>Операторы <B>length</B>, <B>put</B>, <B>get</B> и <B>forall</B> 
      работают как с массивами, так и со строками и словарем. Так <B>length</B> 
      -- возвращает длину строки, массива или число пар ключ-значение в словаре. 

      <P>Еще два оператора, <B>aload</B> и <B>astore</B> облегчают загрузку и 
      сохранение сразу всего массива. Так оператор <B>aload</B> берет в качестве 
      аргумента массив, заносит в стек по очереди все его элементы, а затем 
      заносит туда сам массив. Так строка <PRE class=example> [1 2 3] aload </PRE>
      <P>оставит в стеке: <PRE class=example>1 2 3 [1 2 3] </PRE>
      <P>оператор <B>astore</B> выполняет обратную функцию. <PRE class=example>1 2 3  3 array astore </PRE>
      <P>создаст массив <PRE class=example>  [1 2 3] </PRE>
      <H2>Еще раз о шрифтах</H2>
      <P>Для печати текста часто требуются различные операции по выравниванию 
      слов по границам страницы, выравниванию промежутков между буквами 
      (<B>кернинг</B>), чтобы напечатанный текст выглядел приятно. Для этой цели 
      в PostScript имеется 4 варианта оператора <B>show</B>: 
      <UL>
        <LI><B>ashow</B> - при печати строки добавляет после каждого символа 
        заданный промежуток; 
        <LI><B>widthshow</B> - при печати строки добавляет заданный промежуток 
        после каждого появления некоторого символа (например после каждого 
        пробела); 
        <LI><B>awidthshow</B> - является комбинацией двух предыдущих операторов; 

        <LI><B>kshow</B> - выполняет заданную процедуру между каждой парой 
        символов в строке. </LI></UL>
      <P>Текущий символ и символ, следующий за ним передаются этой процедуре как 
      аргументы. Так строка <PRE class=example>   {pop pop (-) show} (World) kshow </PRE>
      <P>напечатает его с дефисом между каждой парой букв: <PRE class=example>  W-o-r-l-d </PRE>
      <P>Оба символа удаляются из стека, так как данная прцедура их не 
      использует. В основном оператор предназначен для кернинга, но может быть 
      использован и в других целях. 
      <H2>Кодирование шрифта</H2>
      <P>Каждый словарь шрифта содержит описание символов в соответствии с 
      некоторой кодовой таблицей, в частности это может быть <B>ASCII</B>. Таким 
      образом каждый символ имеет свой цифровой код -- число от 0 до 255. 
      Кодовая таблица не является постоянной, ее можно изменять из приложения. 
      <P>Коды символов можно использовать двумя способами: 
      <UL>
        <LI>их можно с помощью оператора <B>put</B> вставлять в строку; 
        <LI>или непосредственно использовать в строке в виде восьмеричных чисел. 
        </LI></UL>
      <P>Многие шрифты имеют символы не входящие в стандартную кодировку и кроме 
      того, часто такие символы отсутствуют на клавиатуре. Чтобы посмотреть как 
      кодируются символы того или иного шрифта, напишем программу, которая 
      распечатывает кодовую таблицу любого заданного шрифта. <PRE class=example>   /Helvetica findfont
           12 scalefont
            setfont
   /cod 3 string def
   /char 1 string def

   /newline {
       currentpoint 13 sub
       exch pop LM
       exch moveto
   } def

   /prtnum {        % в стеке код
       cod cvs show
   } def

   /prtchar {       % в стеке код
       char 3 - 1 0 roll put
       char show
   } def

   /prtall {
       dup prtnum () show
       prtchar newline
   } def

%%%% основная программа %%%%
   /LM 72 def      % печатаем первую колонку
    LM 450 moveto
   12 1 60 {prtall} for

   /LM 144 def     % печатаем вторую колонку
    LM 144 moveto
    6 1 100 {prtall} for
  showpage </PRE>
      <P>Преобразование шрифта задается матрицей преобразования (трансформации), 
      представляющей из себя массив из шести чисел. Они определяют, как 
      координаты пространства пользователя должны быть трансформированы в 
      позицию на текущей странице. Элементы этого массива определяют масштаб, 
      ориентацию и позицию осей <B>х</B> и <B>у</B>. 
      <P>Графическое состояние программы работает с текущей матрицей 
      трансформирования, определяющей, как на текущей странице позиционируются 
      все изображения. 
      <P>Операторы <B>translate</B>, <B>rotate</B> и <B>scale</B> для 
      модификации координат пространства пользователя изменяет соответствующие 
      элементы этой матрицы. 
      <P>Отдельная матрица преобразования ассоциируется с каждым шрифтом, 
      определяя как символы этого шрифта должны печататься на текущей странице. 
      Эта матрица шрифта может быть изменена непосредственно оператором 
      <B>makefont</B>, который берет из стека словарь шрифта и шестиэлементный 
      массив, а затем преобразует с помощью этого массива матрицу шрифта и 
      помещает измененный словарь шрифта обратно в стек. 
      <P>Чтобы изменить масштаб шрифта по <B>х</B> и по <B>у</B>, нужно задать 
      соответственно значения чисел <B>m</B> и <B>n</B> в матрице <PRE class=example>  [m 0 0 n 0 0 ] </PRE>
      <P>Так строки <PRE class=example>   /Helvetica findfont
            6 scalefont </PRE><PRE class=example>    /Helvetica findfont
      [6 0 0 6 0 0] makefont </PRE>
      <P>выполняют ровно одно и тоже: создают шрифт Helvetica размером 6 
      пунктов. Действие оператора <B>makefont</B> однако значительтно шире, чем 
      у <B>scalefont</B>. Он позволяет как угодно сжимать и растягивать текст. 
      Следующая программа из "Голубой книги" показывает технику работы с 
      <B>makefont</B>. <PRE class=example>  /basefont /Helvetica findfont def
  /LM 72 def
  /newline {
     currentpoint 13 sub
     exch pop LM
     exch moveto
  } def

%%%% основная программа
   LM 400 moveto
                          % обычная печать
  basefont [12 0 0 12 0 0] makefont setfont
(Пример нормальной печати) show newline
                          % растянутый.
  basefont [17 0 0 12 0 0] makefont setfont
(Растянутый шрифт) show newline
                          % сжатый
 basefont [7 0 0 12 0 0] makefont setfont
(Сжатый шрифт) show newline
                          % наклонный
basefont [12 0 6.93 12 0 0] makefont setfont
(Наклонный шрифт) show

showpage </PRE>
      <P>Программа печатает четыре строки, каждый раз преобразуя текущий шрифт, 
      с помощью различных матриц шрифта. Во второй и третьей строке изменялся 
      масштаб по горизонтали (Вы можете поэксперементировать, задавая различный 
      масштаб и по вертикали, но не забудьте поменять константу в процедуре 
      <B>newline</B>, чтобы строки не наползали одна на другую). Интересна 
      последняя строка. Третье число в матрице <B>6.93</B> представляет собой 
      результат умножения <B>у</B> на <B>tg 30</B> градусов. Таким образом задан 
      наклон шрифта. 
      <P>Вы можете поэкспериментировать с матрицами преобразования, чтобы лучше 
      почувствовать, что происходит с шрифтом. 
      <P>Все эти преобразования пространства пользователя можно выполнить также 
      с помощью операторов <B>scale</B> и <B>setmatrix</B>. Однако в отличие от 
      <B>makefont</B> их действие распространяется на все, что печатается на 
      текущей странице. Если нужно сжать, растянуть или наклонить текст, то 
      следует пользоваться только <B>makefont</B>. 
      <P class=date>20.11.2001 </P></TD></TR></TBODY></TABLE>
<CENTER>
<HR>

<HR width="50%">
©Фурашев А. 2002<BR><A href="mailto:psdraw@narod.ru">e-mail</A>
<HR width="25%">

<HR width="12%">
<!-- ><!-- "><!-- '><!-- --></TEXTAREA></FORM> </TITLE></COMMENT></A>
<DIV></DIV></SPAN></ILAYER></LAYER></IFRAME></NOFRAMES></STYLE></NOSCRIPT></TABLE></SCRIPT></APPLET></FONT>
<STYLE>#bn {
	DISPLAY: block
}
#bt {
	DISPLAY: block
}
</STYLE>

<SCRIPT language=JavaScript src="les4_files/163"></SCRIPT>
<!-- mailto:spm111@yandex.ru --></CENTER></BODY></HTML>
