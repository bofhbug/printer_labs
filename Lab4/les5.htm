<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0031)http://psdraw.narod.ru/les5.htm -->
<HTML><HEAD><TITLE>Язык программирования PostScript: Урок 5</TITLE><LINK 
href="les5_files/main.css" type=text/css rel=STYLESHEET>
<META http-equiv=Content-Type content="text/html; CHARSET=Windows-1251">
<META 
content="PostScript программирование рисование печать язык программирования DPS lang .ps создание" 
name=Keywords>
<META content="MSHTML 6.00.2800.1528" name=GENERATOR></HEAD>
<BODY topMargin=10>
<TABLE borderColor=#c6c6c6 cellSpacing=3 width="100%" border=1>
  <TBODY>
  <TR bgColor=black>
    <TD vAlign=top align=left width="20%">
      <P class=level0><A href="http://psdraw.narod.ru/index.htm">Новости</A>
      <P class=level0><A href="http://psdraw.narod.ru/main.htm">О проекте</A>
      <P class=level0><A href="http://psdraw.narod.ru/why.htm">Зачем?</A>
      <P class=level0><A href="http://psdraw.narod.ru/soft.htm">Используемое 
      ПО</A>
      <P class=level0><A href="http://psdraw.narod.ru/metoda.htm">Методика 
      разработки сцен на PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/stnd.htm">Операторы языка 
      PostScript</A>
      <P class=level0><A href="http://psdraw.narod.ru/lib.htm">Библиотека</A>
      <P class=level0><A href="http://psdraw.narod.ru/les.htm">Изучение 
языка</A>
      <P class=level1><A href="http://psdraw.narod.ru/les1.htm">Урок 1</A>
      <P class=level1><A href="http://psdraw.narod.ru/les2.htm">Урок 2</A>
      <P class=level1><A href="http://psdraw.narod.ru/les3.htm">Урок 3</A>
      <P class=level1><A href="http://psdraw.narod.ru/les4.htm">Урок 4</A>
      <P class=level1>Урок 5
      <P class=level1><A href="http://psdraw.narod.ru/les6.htm">Урок 6</A>
      <P class=level1><A href="http://psdraw.narod.ru/les7.htm">Урок 7</A>
      <P class=level0><A href="http://psdraw.narod.ru/s_sss.htm">Статьи</A>
      <P class=level0><A 
      href="http://psdraw.narod.ru/links.htm">Ссылки...</A></P></TD>
    <TD vAlign=top>
      <H1>Занятие пятое</H1>
      <H2>Версии языка</H2>
      <P>До сих пор мы обходились без указания на различия в версиях различных 
      языка PostScript, но сейчас это необходимо сделать. Начнём с небольшого 
      экскурса в историю языка. 
      <P>Итак язык PostScript был разработан фирмой Adobe Systems в 1985. За эти 
      годы он активно развивался: в следующих версиях добавилась работа с 
      цветом, изображениями и т.д. Реализации PostScript организованы по 
      уровням. Различают языки <B>PostScript Level 1</B> более поздний, 
      <B>PostScript Level 2</B>. Отметим, что ядро языка при этом не изменилось. 
      <B>PostScript Level 2</B> адаптирован для новых технологий печати, в него 
      добавлено около 150 новых операторов, оформленных в виде расширений языка. 
      Для нас важно, что эти реализации языка совместимы снизу-вверх, т. е. 
      программа, написанная для реализации <B>Level 1</B> будет выполнена в 
      интерпретатором для <B>PostScript Level 2</B>. Далее мы будем помечать 
      операторы, относящиеся к Level 2 знаком (<B>L2</B>). 
      <P>Есть несколько способов определить, какой уровень языка поддерживает 
      ваше оборудование, его название, версию и номер релиза. 
      <P><B class=operator>languagelevel</B> - определение поддерживаемого 
      уровня языка. <PRE class=example>  languagelevel -&gt;  а (уровень) </PRE>
      <P>Уровень - это целое число, обозначающее уровень языка PostScript, 
      поддерживаемый интерпретатором. Если он равен <B>2</B>, то интерпретатором 
      поддерживается язык <B>PostScript Level 2</B>. Если <B>1</B> или слова нет 
      в словаре <B>systemdict</B>, то интерпретатор не поддерживает Level 2. 
      <P><B class=operator>version</B> -- возвращает строку, которая 
      идентифицирует используемую версию интерпретатора языка PostScript. Эта 
      идентификация не включает информацию о возможностях языка, аппаратных 
      средствах или операционной среде, в которой работает интерпретатор. <PRE class=example>  version       -&gt;  a (версия) </PRE>
      <P><B class=operator>product</B> -- возвращает объект типа строки только 
      для чтения, содержащую название продукта, в котором исполняется 
      интерпретатор языка PostScript. <PRE class=example> product        -&gt;  а (строка) </PRE>
      <P><B class=operator>revision</B> -- возвращает целое число, обозначающее 
      текущий уровень продукта, в котором исполняется интерпретатор PostScript. 
      Каждый продукт имеет собственную систему нумерации релизов, независящую от 
      нумерации любых других продуктов. <PRE class=example> revision       -&gt;  а (целое число) </PRE>
      <H2>Вывод информации</H2>
      <P><B class=operator>print</B> -- записывает символы строки в стандартный 
      файл вывода. Оператор <B>print</B> предоставляет простое средство для 
      пересылки текста приложению или пользователю. Этот оператор не рисует 
      символы на текущей странице (для этого используется операторы <B>show</B> 
      и <B>showpage</B>). <PRE class=example> (строка) print </PRE>
      <P><B class=operator>==</B> называется "два знака равно" (twoequals). Она 
      введена в язык для удобства отладки. 
      <P><B>==</B> извлекает объект из стека операндов, создаёт его текстовое 
      представление, близкое по форме к синтаксиссу PostScript, помещает вслед 
      за ним знак перевода строки и записывает результат на стандартное 
      устройство вывода. Имя <B>==</B> не является специальным: в программе на 
      PostScript оно может быть разделено "белыми" пробелами или специальными 
      символами, как и имя составленное из букв. 
      <H2>Встроенные функции</H2>
      <P>Некоторые встроенные функции были рассмотрены на первом занятии. Сейчас 
      мы добавим к ним ещё десяток, связанных с работой с числами. 
      <P><B class=operator>ceiling</B> -- возвращает ближайшее целое число, 
      большее или равное операнду из вершины стека. Тип результата совпадает с 
      типом операнда. <PRE class=example> ceiling         -&gt; а (целое число) </PRE>
      <P>Примеры: <PRE class=example>   -1.9 ceiling  -&gt; -1.0
    5.3 ceiling  -&gt;  5.0
     49 ceiling  -&gt;  49   </PRE>
      <P><B class=operator>round</B> -- возвращает целое число, ближайшее к ее 
      операнду. Если аргумент дробная часть аргумента больше или равна 0.5, то 
      возвращается большее целое число. Тип результата совпадает с типом 
      операнда. Например: <PRE class=example>   -1.9 round    -&gt; -2.0
    8.5 round    -&gt;  9.0
   -8.5 round    -&gt; -7.0 </PRE>
      <P><B class=operator>truncate</B> - возвращает целую часть своего 
      операнда. Например: <PRE class=example>    1.9 truncate -&gt;  1.0
   -3.4 truncate -&gt; -3.0 </PRE>
      <P><B class=operator>floor</B> -- возвращает наибольшее целое число 
      меньшее или равное операнду. Например: <PRE class=example>    1.9 floor    -&gt;  1.0
   -3.7 floor    -&gt; -4.0 </PRE>
      <P><B class=operator>cvi</B> - берёт из стека число типа <B>integer</B>, 
      <B>real</B> или <B>строку</B> и конвертирует его в целое число. У чисел 
      типа <B>real</B> отбрасывается дробная часть, но, если это число больше 
      максимально представимого в виде целого, возникает ошибка. Строка 
      рассматривается как последовательность символов с записью числа в принятой 
      в PostScript нотации. Например: <PRE class=example>  17.83 cvi      -&gt;   17
 -17.83 cvi      -&gt;  -17</PRE>
      <P><B class=operator>cvlit</B> -- конвертирует объект из вершины стека 
      операндов из исполняемой формы в литерал. 
      <P><B class=operator>cvr</B> -- работает аналогично <B>cvi</B>, только 
      результат преобразования - число типа <B>real</B>. 
      <P><B class=operator>cvs</B> - конвертирование в строку. Создаёт текстовое 
      представление произвольного объекта что-либо, записывает его в строку 
      (стирая то, что было в строке ранее) и возвращает подстроку. Если объект 
      число, то возвращается его строковое представление. Для логических 
      объектов возвращается строка со соловом <B>true</B> или <B>false</B>. 
      Строку <B>cvs</B> просто копирует в другую строку. Если объект имя или 
      оператор, <B>cvs</B> возвращает текстовое представление этого имени или 
      оператора. Во всех других случаях возвращается текст 
      <B>--nostringval--</B>. Например: <PRE class=example> /newstr 10 string def  %% объявляем строковую переменную
     1996 4 add newstr cvs       -&gt; (2000)</PRE>
      <P><B class=operator>cvrs</B> - конвертирование в строку в заданной 
      системе счисления. Работает как <B>cvs</B>, но при конвертировании 
      результат записывается в заданной системе счисления. Если она десятичная, 
      то ничем не отличается от <B>cvs</B> (или <B>cvi</B>, если число типа 
      <B>integer</B>). <PRE class=example> Синтаксис:
    Число СистемаСчисления Строка cvrs   -&gt; (подстрока) </PRE><PRE class=example> /tmp 14 string def            % строковая перемен на 14 символов
     99 10 temp cvrs   -&gt; (99) % 99  представ в десятиричн системе счисления
    144 16 temp cvrs   -&gt; (E0) % 144 представ в шестнадцатиричн системе счислен</PRE>
      <P><B class=operator>cvn</B> - конвертирует строку операнда в имя объекта, 
      совпадающее с ней лексически. Имя объекта исполняемо. Например: <PRE class=example> (abc) cvn    -&gt;  /abc</PRE>
      <P><B class=operator>cvx</B> - конвертирование в исполняемую форму. Делает 
      литеральный объект что-либо из вершины стека операндов исполняемым. 
      Возможность выполнить динамически создаваемую процедуру. 
      <H3>Логические операторы</H3>
      <P>Логические операторы в PostScript работают как с целыми числами, так и 
      с логическими. В первом случае операция выполняется над операндом 
      поразрядно. Имеется четыре основных логических операции: <B>and</B>, 
      <B>or</B>, <B>not</B> и <B>xor</B> (из которых, как известно, можно 
      построить все остальные булевские функции). Для краткости ниже дан пример 
      только для <B>xor</B>. 
      <P><B class=operator>xor</B> - если оба операнда логические величины, то в 
      стеке возвращается результат операции "<B>исключающее ИЛИ</B>", если 
      операнды - типа <B>integer</B>, в стек помещается результат поразрядной 
      операции <B>xor</B> над их двоичным представлением. <PRE class=example>  bool1 bool2 xor  -&gt; bool3
   int1  int2 xor  -&gt; int3 </PRE><PRE class=example> true false xor   -&gt; true </PRE>
      <H3>Операторы сравнения</H3>
      <P><B class=operator>ge</B> - больше или равно. Извлекает два объекта из 
      стека операндов и помещает в него значение <B>true</B>, если первый 
      операнд больше или равен второму. Строки сравниваются посимвольно. <PRE class=example>  8.2 8.1 ge       -&gt; true </PRE>
      <P>Аналогично работают и другие операторы сравнения: 
      <P><B class=operator>gt</B> - больше чем 
      <P><B class=operator>eq</B> - равно 
      <P><B class=operator>ne</B> - не равно 
      <P><B class=operator>le</B> - меньше равно 
      <P><B class=operator>lt</B> - меньше чем. 
      <P><B class=operator>bitshift</B> -- логический сдвиг числа. Сдвигает 
      двоичное представление целого числа <B>integer1</B> влево на <B>shift</B> 
      разрядов, если <B>shift</B> положительно, или вправо, если отрицательно. 
      Возвращает результат <B>integer2</B>. Биты исходящие теряются, а входящие 
      -- обнуляются. Оба операнда должны быть целыми числами. Например: <PRE class=example>   5 4 bitshift   -&gt; 80
144 -3 bitshift   -&gt; 56</PRE>
      <H3>Генерация случайных чисел</H3>
      <P><B class=operator>rand</B> - помещает в стек случайное целое число типа 
      <B>integer</B> в диапазоне от <B>0</B> до <B>231-1</B>, полученное с 
      помощью генератора псевдо-случайных чисел. <PRE class=example> rand            -&gt;  int</PRE>
      <P><B class=operator>rrand</B> -- возвращает целое число, представляющее 
      текущее состояние генератора случайных чисел, используемого оператором 
      <B>rand</B>. Оно может быть затем использовано в качестве операнда 
      оператора <B>srand</B>, чтобы возобновить генерацию случайных чисел с 
      текущей позиции в последовательности получаемых с его помощью чисел. <PRE class=example> rrand           -&gt;  int </PRE>
      <H3>Время</H3>
      <P><B class=operator>realtime</B> -- возвращает отсчет таймера, считающего 
      реальное время независимо от интерпретатора PostScript. Минимальный 
      интервал отсчитываемого времени равен одной миллисекунде, начальное 
      значение и частота обновления счётчика произвольны и зависят от 
      реализации. Как только значение счётчика времени станет больше, чем 
      <B>максимально большое</B> целое число, интерпретатор меняет его на 
      <B>0</B> или, в некоторых реализациях на наименьшее целое (наибольшее 
      отрицательное) число. (<B>L2</B>). <PRE class=example> realtime        -&gt; int </PRE>
      <P><B class=operator>usertime</B> - возвращает значения интервального 
      таймера, который увеличивается на <B>1</B> за каждую миллисекунду работы 
      интерпретатора PostScript. Это значение никак не связано с календарным 
      временем. При достижении предельного значения счётчика он, в зависимости 
      от реализации, устанавливается либо равным нулю, либо наибольшему 
      отрицательному целому числу. <PRE class=example> usertime        -&gt; int</PRE>
      <H2>Контуры символов</H2>
      <P>Напомню, что по способу представления в компьютере шрифты делятся на 
      векторные и растровые. Каждый словарь шрифта в PostScript содержит 
      описание вида входящих в данный шрифт символов. В большинстве шрифтов 
      символы описываются контуром (представленным в виде векторов), который 
      заполняется каким-либо цветом при печати конкретного символа. Растровые 
      шрифты описывают символы как линии, которые должны быть начерчены или как 
      битовую карту. 
      <P>Контурное или линейное описания символа могут быть непосредственно 
      использованы в операторе <B>charpath</B>. Вместо рисования траектории 
      оператор <B>charpath</B> добавляет её к текущей пути. Это позволяет 
      производить над результатом различные операции заполнения отсечения и т.д. 
      Он берет из стека строку и логическое выражение и добавляет к текущему 
      пути контур символа, который описан в данной строке. Логическое выражение 
      определяет тип оставляемого контура т.е. что произойдёт, если траектория 
      символа предназначена для штриховки, а не для заполнения или 
      оконтуривания. Если значение операнда <B>false</B>, то <B>charpath</B> 
      просто добавляет траекторию символа, которая точно отображает описание 
      символа в словаре шрифта, к текущему пути (результат удобный только для 
      штрихового заполнения). Если операнд <B>true</B>, то <B>charpath</B> 
      применяет к траектории символа оператор <B>strokepath</B> и полученный 
      результат можно использовать для заливки каким-либо цветом (но не для 
      штриховки). Если все символы шрифта будут заливаться, то разницы не видно. 
      Оператор <B>charpath</B> не работает с теми частями символа, которые 
      определенны как изображения или маски не являющиеся траекториями. 
      Например: <PRE class=example>(B) false charpath
(B) true charpath</PRE>
      <P>Следует учесть, что контуры некоторых шрифтов защищены. в реализации 
      языка PostScript Level 1 это относится ко всем шрифтам, в PostScript Level 
      2 - только некоторых специальных шрифтов и не относится к обычным шрифтам 
      Type 1 или Type 3. Если текущий шрифт защищён, использование charpath, 
      чтобы получить их контуры, вызывает блокирование работы операторов 
      pathforall и upath до тех пор пока контуры символов из такого шрифта 
      остаются в текущей траектории. 
      <P>Путь построенный с помощью <B>charpath</B> может быть вычерчен либо 
      заполнен (залит). 
      <P>Пример использования тривиальная рекламная виньетка с названием вашей 
      фирмы. Для этого поэспериментируйте с текстом этой процедуры. <PRE class=example>    /Helvetica-Bold findfont  % Устанавливаем шрифт
                 24 scalefont
                    setfont
    /oshow {             % Добавляем строку к текущему пути
      true charpath
      stroke
    } def

    /CircleName {  % рисуем фигуру из текста
      30 30 360 %% угол поворота от 30 до 360 шаг 30
     {          %% входим в цикл
       gsave     % сохранили оригин ориентацию осей
         rotate  % повернули оси на текущ угол
         0 0 moveto      % печатаем в начале координат
         (   PostScript) oshow % вот его и печатаем
         grestore % восстановлил оригин ориентацию осей
     } for
    } def

    %%%% Основная программа %%%%
150 350 translate     % печатаем в середине страницы
     .3 setlinewidth  % ширина контура букв
        CircleName
        gsave         % сохраним нарисован путь
    0.8 setgray fill  % заливаем его сереньким
        grestore      % восстановили нарисован путь
        stroke        % обводим буквы
showpage</PRE>
      <H2>Траектория отсечения</H2>
      <P>В графическом состоянии PostScript имеется траектория отсечения 
      (<B>clipping path</B>), представляющая собой границы области на текущей 
      странице, в которой изображения могут быть нарисованы. Первоначально этот 
      путь совпадал с углами бумаги, используемой принтером. Текущая траектория 
      отсечения может быть изменена с помощью оператора <B>clip</B>. Этот 
      оператор делает текущую траекторию траекторией отсечения. Все последующие 
      "рисующие" операторы будут отсекаться, если изображение выходит за границы 
      траектории отсечения. 
      <P>Например, следующая программа конструирует траекторию в виде 
      треугольника и делает его траекторией отсечения. Затем она рисует 
      прямоугольную сетку и после печати мы видим, что осталось только та часть 
      сетки, которая попала в этот прямоугольник. <PRE class=example>  /inch {72 mul} def  % перевод дюймы в пункты

  /triangle {         % рисуем треугольник
                   newpath
    0      0        moveto
    2 inch 0        lineto
    1 inch 2.8 inch lineto
                    closepath
  } def

  /vgrid {            % рисуем вертикальн сетку
         newpath
   0 9 2 inch         % от 0 до 2 дюймов с шагом 9 пунктов
   {
     0   exch moveto
     0 3 inch rlineto % рисуем вертикальн линию длиню 3 дюйма
   } for
   stroke             % нарисован сетку обводим
  } def

 /hgrid  {            % рисуем горизонтальн сетку
           newpath    % аналогично вертикальн
  0 10 2.8 inch
  {
    0   exch moveto
    2 inch 0 rlineto
  } for
  stroke
 } def

%%%% Основная программа %%%%
 200 300 translate  % здесь и рисуем
 triangle clip      % делаем треугольник областью отсечения
 vgrid           % ну и сеточку рисуем
 hgrid
showpage </PRE>
      <P>В качестве отсекающих границ может быть использован любая траектория, 
      включая и след символа, оставляемый оператором <B>сharpath</B>. 
      <P class=date>21.11.2001 </P></TD></TR></TBODY></TABLE>
<CENTER>
<HR>

<HR width="50%">
©Фурашев А. 2002<BR><A href="mailto:psdraw@narod.ru">e-mail</A>
<HR width="25%">

<HR width="12%">
<!-- ><!-- "><!-- '><!-- --></TEXTAREA></FORM> </TITLE></COMMENT></A>
<DIV></DIV></SPAN></ILAYER></LAYER></IFRAME></NOFRAMES></STYLE></NOSCRIPT></TABLE></SCRIPT></APPLET></FONT>
<STYLE>#bn {
	DISPLAY: block
}
#bt {
	DISPLAY: block
}
</STYLE>

<SCRIPT language=JavaScript src="les5_files/163"></SCRIPT>
<!-- mailto:spm111@yandex.ru --></CENTER></BODY></HTML>
